(in-ns 'math.linalg)

(def print-matrix)
(defstruct matrix :rows :cols :data)

(with-test
    (defn matr
      "Create a matrix with dimensions and data.
  Any other matrix constructors should use this to make sure metadata
  is set correctly."
      ([data]
         (matr (count data)
               (count (first data))
               (apply concat data)))
      ([dim data]
         (matr dim dim data))
      ([rows cols data]
         (with-meta (assoc (struct matrix rows cols (vec data))
                      :type ::Matrix)
                    {:custom-print print-matrix})))
  (let [m1 (matr 3 2 (range 1 7))
        m2 (matr 2 [1 2 3 4])
        m3 (matr [[1 2 3] [4 5 6]])]
    (is (= 3 (:rows m1)))
    (is (= 2 (:cols m1)))
    (is (= [1 2 3 4 5 6] (:data m1)))
    (is (= 2 (:rows m2) (:cols m2)))
    (is (= [1 2 3 4] (:data m2)))
    (is (= 2 (:rows m3)))
    (is (= 3 (:cols m3)))
    (is (= [1 2 3 4 5 6] (:data m3)))))

(with-test
    (defn dim
      "Get the dimensions of the matrix.
  If it's a vector, return a scalar with the length of the vector
  Otherwise, return a Clojure vector with the number of rows and the
  number of columns."
      [m]
      (cond (= (:rows m) 1) (:cols m)
            (= (:cols m) 1) (:rows m)
            true [(:rows m) (:cols m)]))
  (is (= 2 (dim (matr 1 2 [3 4]))))
  (is (= 3 (dim (matr 3 1 [1 2 3]))))
  (is (= [3 4] (dim (matr 3 4 (range 12))))))

(defmethod =? [Number ::Matrix] [n m]
  (every? #(=? n %) (:data m)))

(defmethod =? [::Matrix ::Matrix] [m1 m2]
  (assert (= (dim m1) (dim m2)))
  (every? #(=? ((:data m1) %)
               ((:data m2) %))
          (range (count (:data m1)))))

(with-test
    (defn cvec
      "Creates a column vector with the data.
  The vector will have 1 column and rows to fit the data."
      [& data] (matr (count data) 1 (vec data)))
  (let [v (cvec 1 2 3)]
    (is (= 3 (dim v)))
    (is (= 3 (:rows v)))
    (is (= 1 (:cols v)))
    (is (= [1 2 3] (:data v)))))

(with-test
    (defn rvec
      "Creates a row vector with the data.
  The vector will have 1 row and columns to fit the data."
      [& data] (matr 1 (count data) (vec data)))
  (let [v (rvec 1 2 3)]
    (is (= 3 (dim v)))
    (is (= 1 (:rows v)))
    (is (= 3 (:cols v)))
    (is (= [1 2 3] (:data v)))))

(with-test
    (defn vec?
      "Is this matrix actually a vector? Does it have only one row or
  only one column?"
      [m] (not (vector? (dim m))))
  (is (vec? (matr 1 1 [3])))
  (is (vec? (matr 1 3 (range 3))))
  (is (vec? (matr 3 1 (range 3))))
  (is (not (vec? (matr 2 3 (range 6))))))

(with-test
    (defn cvec?
      "Is this a column vector?"
      [v] (= 1 (:cols v)))
  (is (cvec? (cvec 1 2 3)))
  (is (cvec? (matr 2 1 [1 2])))
  (is (not (cvec? (rvec 1 2 3)))))

(with-test
    (defn rvec?
      "Is this a row vector?"
      [v] (= 1 (:rows v)))
  (is (rvec? (rvec 1 2 3)))
  (is (rvec? (matr 1 3 [1 2 3])))
  (is (not (rvec? (cvec 1 2 3)))))

(with-test
    (defn- flattened-index
      "Takes a row and column index and turns it into a single index
  for the data vector of the matrix."
      [m i j]
      (+ (dec j)
         (* (dec i) (:cols m))))
  (let [m (matr 3 4 (vec (range 12)))]
    (is (= 0 (flattened-index m 1 1)))
    (is (= 1 (flattened-index m 1 2)))
    (is (= 2 (flattened-index m 1 3)))
    (is (= 5 (flattened-index m 2 2)))
    (is (= 8 (flattened-index m 3 1)))
    (is (= 11 (flattened-index m 3 4)))))

(with-test
    (defn mget
      "Get an element of a matrix or vector
  Matrix indexing starts at 1 and ends at the number of rows/columns
  (inclusive)."
      ([m i]
         (assert (vec? m))
         ((:data m) (dec i)))
      ([m i j] ((:data m) (flattened-index m i j))))
  (let [m (matr 2 3 (range 1 7))]
    (is (= 1 (mget m 1 1)))
    (is (= 2 (mget m 1 2)))
    (is (= 3 (mget m 1 3)))
    (is (= 4 (mget m 2 1)))
    (is (= 5 (mget m 2 2)))
    (is (= 6 (mget m 2 3)))
    (is (= 1 (mget (cvec 1 2 3) 1)))
    (is (= 3 (mget (rvec 1 2 3) 3)))))

(with-test
    (defn- expanded-index
      "Takes an index for the data vector and turns it into a row and
  column index for the matrix."
      [m i] [(inc (int (Math/floor (/ i (:cols m)))))
             (inc (rem i (:cols m)))])
  (let [m (matr 2 3 (range 6))]
    (is (= [1 1] (expanded-index m 0)))
    (is (= [1 2] (expanded-index m 1)))
    (is (= [1 3] (expanded-index m 2)))
    (is (= [2 2] (expanded-index m 4)))
    (is (= [2 3] (expanded-index m 5)))))

(with-test
    (defn gen-matrix
      "Create a matrix of given dimensions whose data is generated by a
  function. The function should take two arguments, a row index and a
  column index, and return the value that belongs at that position."
      [r c fun]
      (let [m (matr r c [])]
        (assoc m :data (vec (map #(apply fun (expanded-index m %))
                                 (range 0 (* r c)))))))
  (let [m (gen-matrix 2 3 +)]
    (is (= 2 (mget m 1 1)))
    (is (= 3 (mget m 1 2)))
    (is (= 5 (mget m 2 3)))))

(defn massoc [m r c val]
  (gen-matrix (:rows m)
              (:cols m)
              #(if (and (= r %) (= c %2))
                 val
                 (mget m % %2))))

(with-test
    (defn mat?
      "Is this a matrix and not a vector?"
      [m] (vector? (dim m)))
  (is (not (mat? (matr 1 3 (range 3)))))
  (is (not (mat? (matr 3 1 (range 3)))))
  (is (not (mat? (matr 1 1 [3]))))
  (is (mat? (matr 2 3 (range 6)))))

(with-test
    (defn square?
      "Does this matrix have matching numbers of rows and columns? This
  is a requirement for a few different operations."
      [m] (and (mat? m)
               (= (:rows m) (:cols m))))
  (is (square? (matr 3 3 (range 9))))
  (is (square? (matr 2 2 (range 4))))
  (is (not (square? (matr 1 1 [1]))))
  (is (not (square? (matr 2 1 (range 2)))))
  (is (not (square? (matr 3 2 (range 6))))))

(with-test
    (defn row
      "Gets the vector for a row of a matrix"
      [m i] (gen-matrix 1 (:cols m)
                        (fn [_ j] (mget m i j)))))

(with-test
    (defn col
      "Gets the vector for a column of a matrix"
      [m j] (gen-matrix (:rows m) 1
                        (fn [i _] (mget m i j)))))

(defn rows
  "Returns a seq of the row vectors of the matrix"
  [m] (map (partial apply rvec)
           (partition (:cols m) (:data m))))

(defn cols
  "Returns a seq of the column vectors of the matrix"
  [m] (map (partial apply cvec)
           (partition (:rows m)
                      (apply interleave
                             (partition (:cols m) (:data m))))))

(defn diag
  "Returns a seq of the values along the diagonal of the matrix."
  [m] (map #(mget m % %)
           (range 1 (inc (min (:rows m)
                              (:cols m))))))

(defn zero-vec?
  "Checks if a vector is the zero vector (every entry is zero)."
  [v] (=? 0 v))

(defn sub-matrix
  "Retrieves the portion of the matrix starting at the given row and
  column."
  [m r c]
  (let [r (dec r)
        c (dec c)]
    (gen-matrix (- (:rows m) r)
                (- (:cols m) c)
                #(mget m (+ %1 r) (+ %2 c)))))

(defn assoc-sub-matrix
  "Replaces the portion of the matrix starting at the given row and
  column with another matrix."
  [m s r c]
  (let [r (dec r)
        c (dec c)]
    (gen-matrix (:rows m)
                (:cols m)
                #(if (and (> %1 r) (> %2 c))
                   (mget s (- %1 r) (- %2 c))
                   (mget m %1 %2)))))

(defn augment
  "Puts two matrices side-by-side in a new matrix."
  [m1 m2]
  (assert (= (:rows m1) (:rows m2)))
  (gen-matrix (:rows m1)
              (+ (:cols m1) (:cols m2))
              #(if (> %2 (:cols m1))
                 (mget m2 %1 (- %2 (:cols m1)))
                 (mget m1 %1 %2))))

(with-test
    (defn transpose
      "Transpose the rows and columns of the matrix."
      [m]
      (gen-matrix (:cols m)
                  (:rows m)
                  #(mget m %2 %1)))
  (let [m (matr 2 3 (range 6))
        t (transpose m)]
    (is (= [3 2] (dim t)))
    (is (= [0 3 1 4 2 5] (:data t)))))

(with-test
    (defn id
      "Gives an identity matrix with n rows and n columns."
      [n] (gen-matrix n n #(if (= %1 %2) 1 0)))
  (is (= (id 1) (matr 1 1 [1])))
  (is (= (id 2) (matr 2 2 [1 0 0 1])))
  (is (= (id 3) (matr 3 3 [1 0 0 0 1 0 0 0 1]))))

(defn zero
  "Gives a matrix with m rows and n columns filled with zeroes."
  ([m] (zero m m))
  ([m n] (gen-matrix m n (constantly 0))))

(defn magnitude
  "Returns the length of the vector."
  [v]
  (sqrt (reduce + (map #(* % %) (:data v)))))
